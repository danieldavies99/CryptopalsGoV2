package englishscore

import (
	"fmt"
	"io/ioutil"
	"sort"
)

func ScoreText(text []byte) float32 {
	// generated by my CreateScoreTable function
	// being fed the entirity of the text of 1984
	// https://gutenberg.net.au/ebooks01/0100021.txt
	charScores := map[byte]float32{
		' ': 16.148602,
		'e': 10.034504, 't': 7.160106,
		'a': 6.065390, 'o': 5.827305,
		'n': 5.358968, 'i': 5.150004,
		's': 4.826766, 'h': 4.778911,
		'r': 4.393853, 'd': 3.191163,
		'l': 3.127299, 'u': 2.190625,
		'c': 1.928016, 'w': 1.909282,
		'm': 1.788196, '\n': 1.753454,
		'f': 1.689419, 'g': 1.547896,
		'y': 1.542617, 'p': 1.368566,
		'b': 1.163349, ',': 1.108000,
		'.': 1.039538, 'v': 0.722772,
		'k': 0.596576, 39: 0.531009,
		'T': 0.300587, '-': 0.294797,
		'I': 0.282024, 'H': 0.183588,
		'W': 0.173540, 'A': 0.145270,
		'B': 0.136925, 'x': 0.132497,
		'O': 0.131986, 'E': 0.104056,
		'S': 0.101842, 'P': 0.094860,
		'N': 0.081065, 'q': 0.067611,
		'?': 0.065567, 'Y': 0.059777,
		'M': 0.053816, 'j': 0.052113,
		'z': 0.051602, 'C': 0.049048,
		'R': 0.046834, 'L': 0.044790,
		'D': 0.044620, '!': 0.043939,
		'F': 0.043768, ':': 0.040022,
		';': 0.029463, 'G': 0.028781,
		'J': 0.026057, 'U': 0.024694,
		'K': 0.016860, '"': 0.016690,
		'1': 0.013454, '0': 0.010899,
		'V': 0.010729, ')': 0.008515,
		'(': 0.008515, '9': 0.006642,
		'4': 0.004428, '2': 0.003917,
		'3': 0.003917, '8': 0.003917,
		'5': 0.003236, '6': 0.002214,
		'X': 0.002214, 'Q': 0.002044,
		'7': 0.001703, '*': 0.000852,
		'Z': 0.000511, ']': 0.000341,
		'[': 0.000341, '=': 0.000170,
		'+': 0.000170,
	}

	var score float32 = 0
	for i := 0; i < len(text); i++ {
		score += charScores[text[i]] // if charScores doesn't contain letter, it will return 0, ty golang
	}
	return score
}

// prints a score table to the console that I can hard code
// into my score function above.
// One cool thing about this is that you could probably feed different
// language texts into it to generate different tables, if you thought that
// your output might be in a different language
//
// - I was a bit worried about performance, but even with the entire text of
// 1984 this ran in ~1 second, which is fine as this is essentially
// a pre-processing step and not something that runs every time you want to score
// something
//
// TODO - missing test coverage
func CreateScoreTable(filepath string) error {
	fileContent, err := ioutil.ReadFile(filepath)
	if err != nil {
		return err
	}

	var scores map[byte]int = map[byte]int{}
	for i := 0; i < len(fileContent); i++ {
		if scores[fileContent[i]] == 0 {
			scores[fileContent[i]] = 1
		} else {
			scores[fileContent[i]] += 1
		}
	}

	totalChars := len(fileContent)
	type CharFreq struct {
		character byte
		freq      float32
	}

	var charFreqs []CharFreq
	for char, freq := range scores {
		charFreqs = append(charFreqs, CharFreq{char, float32(freq) / float32(totalChars) * 100.0})
	}

	// sort by frequency
	sort.Slice(charFreqs, func(i, j int) bool {
		return charFreqs[i].freq > charFreqs[j].freq
	})

	for _, cf := range charFreqs {
		if cf.character == 10 { // line break, escaped to make it easier to copy and paste
			fmt.Printf("'\\n': %f,\n", cf.freq)
		} else if cf.character == 39 { // single quote, , escaped to make it easier to copy and paste
			fmt.Printf("39: %f,\n", cf.freq)
		} else {
			fmt.Printf("'%c': %f,\n", cf.character, cf.freq)
		}
	}

	return nil
}
